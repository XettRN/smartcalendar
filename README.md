# smartcalendar
 
![image](https://user-images.githubusercontent.com/49420152/220363942-2332b3ce-baef-4698-97a5-25e128d74a19.png)


# Problem
Calendars are an essential tool that we use in our daily lives. We use calendars to not only coordinate our schedules but also to be reminded of holidays and events. That’s why many people are using online calendar services like Google Calendar to keep track of their calendars and schedules. This allows them to synchronize their calendar across multiple devices. However, many people find it inconvenient to pull out their phones/computers to check their calendars. Furthermore, many people still enjoy the aesthetic nature of having a calendar for decoration. That’s why many people still use regular calendars or spend money on more expensive smart displays as a substitute for them. 
# Technical Description
Parts Required:
- ESP32
- 8x32 LED Matrix
- Wood & Black Paint for frame
- Acryllic for display
- Woodglue and some sort of adhesive (preferable double-sided tape) for the cutout
- MicroUSB Cable
- Standard paper (will be used with a printer for cutout)
Note:
As of right now, since this project uses an ESP32 for wireless communication, code can only be programmed using PlatformIO and NOT the Arduino IDE. For some reason, the libraries for HTTP Redirecting are only compatible with PlatformIO, which is necessary for this project to work. If you are deadset on using the Arduino IDE, consider using an ESP8266, however, the Bluetooth functionality for this project can’t be used.
There are many different types of ESP32 boards, so do your research on what settings you have to do for your board in the IDE, what are your pinouts, and technical limitations (flash size, system libraries, etc.).
## Programming and Setting Up the ESP32:
First, set up the ESP32 to connect to WiFi and initialize Bluetooth. Add the libraries “TimeLib.h” and “FastLED.h” to your project, since we’ll be using those later. It is recommended that you should do each part piecewise to ensure everything works properly before creating a bunch of code (test WiFi, then Bluetooth, then GET a webpage, so on and so forth). For WiFi, I had to use GTOther instead of eduroam because of complications and restrictions with WPA2 Enterprise WiFi. In order to register the ESP32 to GTOther, you will need to obtain your device’s MAC address or set it yourself. Once you’ve set up WiFi, you’ll need to add Bluetooth. At this point, if you’re using default settings for ESP32 development, your flash size will be too small. In the platformio.ini file, use huge_app.csv as your board partition, and while you’re there, add the correct board (I’m using node32s), serial port (COM5), and speed (115200 baud). Also on your phone install a Bluetooth Serial Monitor app. From there on, set up Bluetooth normally.
Once you are sure both work, it’s time to set up the online connections. But first, you’ll need to create your google script. Check the appendix for the google script code I used, and the GitHub repo for how I use it. For my implementation, I used parameters so any month on your calendar can be displayed. URLs need to be formatted like this “https://script.google.com/macros/s/appid/exec?year=[year]&month=[month]”. From there on you can use the HTTPClient library to GET the response info and parse through the returned string. This script pulls holidays and your own personal google calendar. Once that works, set up time using NTP servers with TimeLib so you can synchronize time correctly.
## Setting Up LED Display and Calendar Cutout:
Now that connectivity works, it’s time to set up the LED display and format the calendar cutout that will be used to display the dates. How this calendar works is that uses a specific calendar cutout format that lets the light shine through the white portion of the paper according to the calendar month. Setting this up can be time-consuming, but I recommend careful measurements and using lines to make an array so aligning things properly is easier. Once that is done, use FastLED to set the appropriate LEDs for the month and the correct dates. I use an XY matrix function that follows a boustrophedon layout of the LEDs on the matrix. This makes setting the correct LED spots much easier than just testing them individually and hardcoding the positions in an array. With the information received from the HTTPS request and parsed accordingly, light up the LEDs appropriately. I use red for weekdays, blue for weekends, green for the current day, cyan for holidays, and yellow for custom events in your google calendar. Setting up the clock is pretty simple, as the TimeLib library makes getting each of these values simple. Make sure to set these LEDs at an appropriate interval, especially calling the google script, as that can take a while and overload (my code makes it so that the calendar updates every minute).
I synchronize to the current time and fetch the current calendar month on startup, but I also check Bluetooth serial once everything is set up so that the calendar can be controlled. Using the app, I check for the ‘+’ or ‘-’ character that once received, increases or decreases the month by one, and that will reset the calendar to the new month. ‘0’ can be inputted to reset the calendar to synchronize with the current time and month.
Creating the Display Box
For this project, I used a laser cutter to cut out all the parts for the display box. The display box has cutouts for the wires that allow the matrix to lay flush in an open box. I created extra sides that can be used as a divider for the calendar and clock. This part of the project could definitely use some more improvement as I’m not very good at assembling things such as these. Once the frame was assembled, I painted the wood black.
With the acrylic, I cut two acrylic screens. One is used as a base that lays flat against all the LEDs. The other is used to trap the paper calendar cutout between two acrylic windows. This keeps the LEDs and the cutout at an appropriate distance to reduce light bleed. I regretfully used small bits of super glue to keep the cutout in place when placing the acrylic on top, which caused the glue to smear on the screen. The ESP32 can be attached however seen fit, I just put a breadboard against the back. Since the ESP32 stores the program, once you flash the code onto the controller you can just hook up a micro USB cable from it to a standard power adapter and it will work normally. 
# Lessons Learned
The hardest part of this project was learning how to hook up to the internet and properly communicate with the ESP32 board. A lot of the example code works on a case-by-case basis, and I had to hop around different libraries and platforms to make everything work. Although the ESP32 has relatively simple code to set things up, creating a server to connect the device to any WiFi isn’t, and as a result, I had to go with hardcoding the connection to GTOther. Furthermore, I had to change the partition and other settings in an environment I wasn’t used to. In this project, I learned how crucial it is to test these things out piecewise instead of just creating a bunch of code and hoping it works.
Another hardship was the creation of the frame. As mentioned before, this isn’t my strong suit. I learned a lot about how to take measurements correctly, and how to use the laser cutter properly. I’m by no means talented when it comes to assembling these types of things, but I learned that this type of thing gets better with practice. The acrylic windows are a bit small, and the sides of the wood frame aren’t glued properly either, but this is amended a lot with the black paint job that makes these mistakes hard to tell. The biggest problem with the design is the lack of casing for the ESP32 and the smearing on the front. The ESP32 aspect was something I didn’t have time to do, but I think I could’ve solved the glue smearing by using double-sided tape instead of superglue, which was the only thing I had on hand at the time.
# Future Work
As mentioned above, I would like to construct the frame with the board in mind so that everything is encased together so that a stand and wall mounts can be put on the back of the display so that it can actually be used as decoration. I would also use double-sided tape to avoid the problem of glue smearing the screen. 
More work can be done to make the display more customizable and adaptable. The current month is adaptable with the Bluetooth serial control, but creating an appropriate user interface could make this a great product. For instance, creating an entire frontend app that connects with the display so that WiFi can be set up wherever and saved instead of hardcoded, and more control over the colors of the LEDs and change the clock between 24-hour and 12-hour formation. However, I think this prototype fulfills the basic requirements that I wanted to solve the initial problem of this project. The use of an LED display with the cutout gives an affordable option to a smart display that doesn’t require a full screen, and its simplicity is something I enjoy.
